<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BigDeal@blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/luwenchun/luwenchun.github.io/"/>
  <updated>2018-03-26T04:24:27.856Z</updated>
  <id>https://github.com/luwenchun/luwenchun.github.io/</id>
  
  <author>
    <name>卢文春</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb常用操作指令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/03/26/mongodb%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/03/26/mongodb使用方法/</id>
    <published>2018-03-26T04:22:50.319Z</published>
    <updated>2018-03-26T04:24:27.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建简单mongodb服务器"><a href="#1-创建简单mongodb服务器" class="headerlink" title="1.创建简单mongodb服务器"></a>1.创建简单mongodb服务器</h3><ul><li><p><code>mongod --dbpath E:\MongoDB\db</code></p></li><li><p><code>mongo.exe</code></p></li></ul><h3 id="2-数据库操作-CRUD"><a href="#2-数据库操作-CRUD" class="headerlink" title="2.数据库操作(CRUD)"></a>2.数据库操作(CRUD)</h3><ul><li><p>显示数据库名称：<code>show dbs</code></p></li><li><p>切换数据库：<code>use &lt;dbname&gt;</code></p></li><li><p>删除当前数据库：<code>db.dropDatabase()</code></p></li><li><p>想要新建数据库，直接使用<code>use &lt;dbname&gt;</code>,在需要的时候会自动创建</p></li><li><p>新建表<code>db.&lt;表名&gt;.insert({})</code>;数据以json的格式</p></li><li><p>显示表名 ：<code>show collections</code></p></li></ul><blockquote><p>例子</p></blockquote><pre><code>&gt; use exapmledb&gt; db.ex_collection1.insert({x:1}) //在表ex_collection1中插入数据{x:1}&gt; show collections输出：ex_collection1system.indexes</code></pre><h4 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h4><ul><li><p>查询 ：<code>db.&lt;表名&gt;.find()</code> 默认返回所有数据</p><p>  <code>&gt; db.ex_collection1.find()</code> </p></li><li><p>查询表中数据，默认返回所有</p><p>  <code>{ &quot;_id&quot; : ObjectId(&quot;58e9e1c6d6ffabd315a4f74a&quot;), &quot;x&quot; : 1 }</code></p><p>  数据库会自动生成一个<code>_id</code>，也可以自己添加，但不能重复</p></li><li><p>条件查询：db.ex_collection1.find({x:1})</p></li><li><p>循环插入</p><p>  <code>&gt; for(i=2;i&lt;50;i++)db.ex_collection1.insert({x:i})</code></p></li><li><p>计算查询出来的总数</p><p>  <code>&gt; db.ex_collection1.find().count()</code>  </p></li><li><p>增加查询条件,下面表示，过滤前3条，返回两条，并且以x排序</p><p>  <code>db.ex_collection1.find().skip(3).limit(2).sort({x:1})</code></p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4></li><li><p>更新数据，比如将<code>x：1</code>的数据改为<code>x：999</code></p><p>  <code>db.ex_collection1.update({x:1},{x:999})</code> </p></li><li><p>部分更新，比如有数据{x:100, y:100, z:100},想要以z:100为条件，更新里面的y为99；</p><p>  <code>db.ex_collection1.update({z:100},{$set:{y:99}})</code></p></li><li><p>更新一条不存在的数据，如果查找y为100的数据，改为y：999，如果不存在的话就直接写入y：999数据,增加第三个参数true即可。</p><p>  <code>db.ex_collection1.update({y:100},{y:999},true)</code></p></li><li><p>更新多条数据，mongodb默认更新一条数据，比如有三条c为1的数据，使用前面方式更新只会修改第一条。</p><p>  <code>db.immoc_collection.update({c:1},{$set:{c:2}},false,true)</code></p></li></ul><h4 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h4><ul><li><p>删除数据</p><p>  <code>db.immoc_collection.remove({c:2})</code></p></li><li><p>删除表</p><p>  <code>db.ex_collection1.drop()</code></p></li></ul><h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><h4 id="3-1-查询创建索引"><a href="#3-1-查询创建索引" class="headerlink" title="3.1 查询创建索引"></a>3.1 查询创建索引</h4><ul><li><p>查询索引</p><p>  <code>db.ex_collection1.getIndexes()</code></p></li><li><p>创建索引(这里的1代表为正向，-1为负向索引)</p><p>  <code>db.imooc_collection.ensureIndex({x:1})</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-创建简单mongodb服务器&quot;&gt;&lt;a href=&quot;#1-创建简单mongodb服务器&quot; class=&quot;headerlink&quot; title=&quot;1.创建简单mongodb服务器&quot;&gt;&lt;/a&gt;1.创建简单mongodb服务器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/09/21/BFC/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/09/21/BFC/</id>
    <published>2017-09-21T14:36:34.387Z</published>
    <updated>2018-03-22T01:51:29.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。要明白BFC到底是什么，首先来看看什么是视觉格式化模型。</p><h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）以及一些实验性的盒（未来可能添加到规范中）。盒的类型由display属性决定。</p><h3 id="块盒（block-box）"><a href="#块盒（block-box）" class="headerlink" title="块盒（block box）"></a>块盒（block box）</h3><p>块盒有以下特性：</p><pre><code>1、当元素的CSS属性display为block，list-item或 table时，它是块级元素 block-level；2、视觉上呈现为块，竖直排列；3、块级盒参与(块格式化上下文)；4、每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如&lt;li&gt;，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。</code></pre><h3 id="行内盒（inline-box）"><a href="#行内盒（inline-box）" class="headerlink" title="行内盒（inline box）"></a>行内盒（inline box）</h3><pre><code>1、当元素的CSS属性display的计算值为inline，inline-block或inline-table时，称它为行内级元素；2、视觉上它将内容与其它行内级元素排列为多行；典型的如段落内容，有文本(可以有多种格式譬如着重)，或图片，都是行内级元素；3、行内级元素生成行内级盒(inline-level boxes)，参与行内格式化上下文(inline formatting context)。同时参与生成行内格式化上下文的行内级盒称为行内盒(inline boxes)。所有display:inline的非替换元素生成的盒是行内盒；4、不参与生成行内格式化上下文的行内级盒称为原子行内级盒(atomic inline-level boxes)。这些盒由可替换行内元素，或 display 值为 inline-block 或 inline-table 的元素生成，不能拆分成多个盒；</code></pre><h3 id="匿名盒（anonymous-box）"><a href="#匿名盒（anonymous-box）" class="headerlink" title="匿名盒（anonymous box）"></a>匿名盒（anonymous box）</h3><p>匿名盒也有份匿名块盒与匿名行内盒，因为匿名盒没有名字，不能利用选择器来选择它们，所以它们的所有属性都为inherit或初始默认值；</p><p>如下面例子，会创键匿名块盒来包含毗邻的行内级盒：</p><pre><code>&lt;div&gt;    Some inline text    &lt;p&gt;followed by a paragraph&lt;/p&gt;    followed by more inline text.&lt;/div&gt;</code></pre><h3 id="三个定位方案"><a href="#三个定位方案" class="headerlink" title="三个定位方案"></a>三个定位方案</h3><p>在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动已经绝对定位。</p><h4 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流(Normal flow)"></a>常规流(Normal flow)</h4><pre><code>在常规流中，盒一个接着一个排列;在块级格式化上下文里面， 它们竖着排列；在行内格式化上下文里面， 它们横着排列;当position为static或relative，并且float为none时会触发常规流；对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；对于相对定位(relative positioning)，position: relative，盒偏移位置由这些属性定义top，bottom，leftandright。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</code></pre><h4 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h4><pre><code>盒称为浮动盒(floating boxes)；它位于当前行的开头或末尾；这导致常规流环绕在它的周边，除非设置 clear 属性；</code></pre><h4 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h4><pre><code>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；它的定位相对于它的包含块，相关CSS属性：top，bottom，left及right；如果元素的属性position为absolute或fixed，它是绝对定位元素；对于position: absolute，元素定位将相对于最近的一个relative、fixed或absolute的父元素，如果没有则相对于body；</code></pre><h3 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h3><p>到这里，已经对CSS的定位有一定的了解了，从上面的信息中也可以得知，块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。<br>BFC的创建方法</p><pre><code>根元素或其它包含它的元素；浮动 (元素的float不为none)；绝对定位元素 (元素的position为absolute或fixed)；行内块inline-blocks(元素的 display: inline-block)；表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；overflow的值不为visible的元素；弹性盒 flex boxes (元素的display: flex或inline-flex)；</code></pre><p>但其中，最常见的就是overflow:hidden、float:left/right、position:absolute。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</p><h3 id="BFC的范围"><a href="#BFC的范围" class="headerlink" title="BFC的范围"></a>BFC的范围</h3><p>BFC的范围在MDN中是这样描述的。</p><pre><code>A block formatting context contains everything inside of the element creating it that is not also inside a descendant element that creates a new block formatting context.</code></pre><p>中文的意思一个BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。<br>这段看上去有点奇怪，我是这么理解的，加入有下面代码，class名为.BFC代表创建了新的块格式化：</p><pre><code>&lt;div id=&apos;div_1&apos; class=&apos;BFC&apos;&gt;    &lt;div id=&apos;div_2&apos;&gt;        &lt;div id=&apos;div_3&apos;&gt;&lt;/div&gt;        &lt;div id=&apos;div_4&apos;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&apos;div_5&apos; class=&apos;BFC&apos;&gt;        &lt;div id=&apos;div_6&apos;&gt;&lt;/div&gt;        &lt;div id=&apos;div_7&apos;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>这段代码表示，#div_1创建了一个块格式上下文，这个上下文包括了#div_2、#div_3、#div_4、#div_5。<br>即#div_2中的子元素也属于#div_1所创建的BFC。但由于#div_5创建了新的BFC，所以#div_6和#div_7就被排除在外层的BFC之外。</p><p>我认为，这从另一方角度说明，一个元素不能同时存在于两个BFC中。</p><p>BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。这是利用BFC清除浮动所利用的特性，关于清除浮动将在后面讲述。</p><p>如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用，所以这个假设就不成立了。</p><h3 id="BFC的效果"><a href="#BFC的效果" class="headerlink" title="BFC的效果"></a>BFC的效果</h3><p>就如刚才提到的，BFC的最显著的效果就是建立一个隔离的空间，断绝空间内外元素间相互的作用。然而，BFC还有更多的特性：</p><pre><code>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &apos;overflow&apos; other than &apos;visible&apos; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the &apos;margin&apos; properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.In a block formatting context, each box&apos;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box&apos;s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</code></pre><h3 id="简单归纳一下："><a href="#简单归纳一下：" class="headerlink" title="简单归纳一下："></a>简单归纳一下：</h3><pre><code>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；处于同一个BFC中的元素相互影响，可能会发生margin collapse；每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；浮动盒区域不叠加到BFC上；</code></pre><p>这么多性质有点难以理解，但可以作如下推理来帮助理解：html的根元素就是<html>，而根元素会创建一个BFC，创建一个新的BFC时就相当于在这个元素内部创建一个新的<html>，子元素的定位就如同在一个新<html>页面中那样，而这个新旧html页面之间时不会相互影响的。</html></html></html></p><p>上述这个理解并不是最准确的理解，甚至是将因果倒置了（因为html是根元素，因此才会有BFC的特性，而不是BFC有html的特性），但这样的推理可以帮助理解BFC这个概念。</p><p>作者：网易考拉前端团队<br>链接：<a href="https://juejin.im/post/59b73d5bf265da064618731d" target="_blank" rel="noopener">https://juejin.im/post/59b73d5bf265da064618731d</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是BFC&quot;&gt;&lt;a href=&quot;#什么是BFC&quot; class=&quot;headerlink&quot; title=&quot;什么是BFC&quot;&gt;&lt;/a&gt;什么是BFC&lt;/h2&gt;&lt;p&gt;BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iconfont图片使用技巧</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/08/29/14/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/08/29/14/</id>
    <published>2017-08-29T14:35:59.877Z</published>
    <updated>2018-03-21T14:23:41.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-class引用"><a href="#font-class引用" class="headerlink" title="font-class引用"></a>font-class引用</h3><hr><p>font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。</p><p>与unicode使用方式相比，具有如下特点：</p><h5 id="1-兼容性良好，支持ie8-，及所有现代浏览器。"><a href="#1-兼容性良好，支持ie8-，及所有现代浏览器。" class="headerlink" title="1.兼容性良好，支持ie8+，及所有现代浏览器。"></a>1.兼容性良好，支持ie8+，及所有现代浏览器。</h5><h5 id="2-相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。"><a href="#2-相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。" class="headerlink" title="2.相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。"></a>2.相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</h5><h5 id="3-因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。"><a href="#3-因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。" class="headerlink" title="3.因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。"></a>3.因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。</h5><h5 id="4-不过因为本质上还是使用的字体，所以多色图标还是不支持的。"><a href="#4-不过因为本质上还是使用的字体，所以多色图标还是不支持的。" class="headerlink" title="4.不过因为本质上还是使用的字体，所以多色图标还是不支持的。"></a>4.不过因为本质上还是使用的字体，所以多色图标还是不支持的。</h5><p>使用步骤如下：</p><h4 id="第一步：引入项目下面生成的fontclass代码："><a href="#第一步：引入项目下面生成的fontclass代码：" class="headerlink" title="第一步：引入项目下面生成的fontclass代码："></a>第一步：引入项目下面生成的fontclass代码：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./iconfont.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第二步：挑选相应图标并获取类名，应用于页面："><a href="#第二步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第二步：挑选相应图标并获取类名，应用于页面："></a>第二步：挑选相应图标并获取类名，应用于页面：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont icon-nav-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>“iconfont”是你项目下的font-family。可以通过编辑项目查看，默认是”iconfont”。</em></p><h2 id="symbol引用"><a href="#symbol引用" class="headerlink" title="symbol引用"></a>symbol引用</h2><hr><p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点：</p><h5 id="1-支持多色图标了，不再受单色限制。"><a href="#1-支持多色图标了，不再受单色限制。" class="headerlink" title="1.支持多色图标了，不再受单色限制。"></a>1.支持多色图标了，不再受单色限制。</h5><h5 id="2-通过一些技巧，支持像字体那样，通过font-size-color来调整样式。"><a href="#2-通过一些技巧，支持像字体那样，通过font-size-color来调整样式。" class="headerlink" title="2.通过一些技巧，支持像字体那样，通过font-size,color来调整样式。"></a>2.通过一些技巧，支持像字体那样，通过font-size,color来调整样式。</h5><h5 id="3-兼容性较差，支持-ie9-及现代浏览器。"><a href="#3-兼容性较差，支持-ie9-及现代浏览器。" class="headerlink" title="3.兼容性较差，支持 ie9+,及现代浏览器。"></a>3.兼容性较差，支持 ie9+,及现代浏览器。</h5><h5 id="4-浏览器渲染svg的性能一般，还不如png。"><a href="#4-浏览器渲染svg的性能一般，还不如png。" class="headerlink" title="4.浏览器渲染svg的性能一般，还不如png。"></a>4.浏览器渲染svg的性能一般，还不如png。</h5><h5 id="使用步骤如下："><a href="#使用步骤如下：" class="headerlink" title="使用步骤如下："></a>使用步骤如下：</h5><h4 id="第一步：引入项目下面生成的symbol代码："><a href="#第一步：引入项目下面生成的symbol代码：" class="headerlink" title="第一步：引入项目下面生成的symbol代码："></a>第一步：引入项目下面生成的symbol代码：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./iconfont.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第二步：加入通用css代码（引入一次就行）："><a href="#第二步：加入通用css代码（引入一次就行）：" class="headerlink" title="第二步：加入通用css代码（引入一次就行）："></a>第二步：加入通用css代码（引入一次就行）：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .icon &#123;</span></span><br><span class="line"><span class="undefined">     width: 1em; height: 1em;</span></span><br><span class="line"><span class="undefined">     vertical-align: -0.15em;</span></span><br><span class="line"><span class="undefined">     fill: currentColor;</span></span><br><span class="line"><span class="undefined">     overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第三步：挑选相应图标并获取类名，应用于页面："><a href="#第三步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第三步：挑选相应图标并获取类名，应用于页面："></a>第三步：挑选相应图标并获取类名，应用于页面：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-nav-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="unicode引用"><a href="#unicode引用" class="headerlink" title="unicode引用"></a>unicode引用</h2><hr><p>unicode是字体在网页端最原始的应用方式，特点是：</p><h5 id="1-兼容性最好，支持ie6-，及所有现代浏览器。"><a href="#1-兼容性最好，支持ie6-，及所有现代浏览器。" class="headerlink" title="1.兼容性最好，支持ie6+，及所有现代浏览器。"></a>1.兼容性最好，支持ie6+，及所有现代浏览器。</h5><h5 id="2-支持按字体的方式去动态调整图标大小，颜色等等。"><a href="#2-支持按字体的方式去动态调整图标大小，颜色等等。" class="headerlink" title="2.支持按字体的方式去动态调整图标大小，颜色等等。"></a>2.支持按字体的方式去动态调整图标大小，颜色等等。</h5><h5 id="3-但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。"><a href="#3-但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。" class="headerlink" title="3.但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。"></a>3.但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</h5><p><em>注意：新版iconfont支持多色图标，这些多色图标在unicode模式下将不能使用，如果有需求建议使用symbol的引用方式</em></p><h5 id="unicode使用步骤如下："><a href="#unicode使用步骤如下：" class="headerlink" title="unicode使用步骤如下："></a>unicode使用步骤如下：</h5><h4 id="第一步：拷贝项目下面生成的font-face"><a href="#第一步：拷贝项目下面生成的font-face" class="headerlink" title="第一步：拷贝项目下面生成的font-face"></a>第一步：拷贝项目下面生成的font-face</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: 'iconfont';</span><br><span class="line">    src: url('iconfont.eot');</span><br><span class="line">    src: url('iconfont.eot?#iefix') format('embedded-opentype'),</span><br><span class="line">    url('iconfont.woff') format('woff'),</span><br><span class="line">    url('iconfont.ttf') format('truetype'),</span><br><span class="line">    url('iconfont.svg#iconfont') format('svg');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二步：定义使用iconfont的样式"><a href="#第二步：定义使用iconfont的样式" class="headerlink" title="第二步：定义使用iconfont的样式"></a>第二步：定义使用iconfont的样式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.iconfont&#123;</span><br><span class="line">    font-family:"iconfont" !important;</span><br><span class="line">    font-size:16px;font-style:normal;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -webkit-text-stroke-width: 0.2px;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三步：挑选相应图标并获取字体编码，应用于页面"><a href="#第三步：挑选相应图标并获取字体编码，应用于页面" class="headerlink" title="第三步：挑选相应图标并获取字体编码，应用于页面"></a>第三步：挑选相应图标并获取字体编码，应用于页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont"</span>&gt;</span>&amp;#x33;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>“iconfont”是你项目下的font-family。可以通过编辑项目查看，默认是”iconfont”。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-class引用&quot;&gt;&lt;a href=&quot;#font-class引用&quot; class=&quot;headerlink&quot; title=&quot;font-class引用&quot;&gt;&lt;/a&gt;font-class引用&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;font-class是unicode使用方式的一种
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>标签样式重置</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/07/27/13/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/07/27/13/</id>
    <published>2017-07-27T14:35:33.179Z</published>
    <updated>2018-03-21T14:08:54.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="美化input框"><a href="#美化input框" class="headerlink" title="美化input框"></a>美化input框</h3><pre><code>/*在IE10+浏览器中, 使用css即可隐藏input文本输入框右侧的叉号*/input[type=text]::-ms-clear,::-ms-reveal{display:none;}input::-ms-clear,::-ms-reveal{display:none;}input{    /*去除点击出现轮廓颜色*/    outline: none;    -webkit-appearance: none; /*去除系统默认的样式，苹果手机上的阴影*/    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /*点击高亮的颜色*/    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/    }</code></pre><h3 id="美化textarea文本域"><a href="#美化textarea文本域" class="headerlink" title="美化textarea文本域"></a>美化textarea文本域</h3><pre><code>textarea{    /*别忘了文本域的box-sizing属性值是border-box;所有的边框和padding都是在你固定的宽高的基础上绘制*/    /*去除点击出现轮廓颜色*/    outline: none;        /*如果有需要，去掉右下角的可拉伸变大小的图标和功能*/    resize: none;    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/}</code></pre><h3 id="改变placeholder的字体颜色大小"><a href="#改变placeholder的字体颜色大小" class="headerlink" title="改变placeholder的字体颜色大小"></a>改变placeholder的字体颜色大小</h3><pre><code>input::-webkit-input-placeholder {     /* WebKit browsers */     font-size:14px;    color: #333;} input:-moz-placeholder {     /* Mozilla Firefox 4 to 18 */     font-size:14px;    color: #333;} input::-moz-placeholder {     /* Mozilla Firefox 19+ */     font-size:14px;    color: #333;} input:-ms-input-placeholder {     /* Internet Explorer 10+ */     font-size:14px;    color: #333;}</code></pre><h3 id="美化select"><a href="#美化select" class="headerlink" title="美化select"></a>美化select</h3><pre><code>/*清除ie的默认选择框样式清除，隐藏下拉箭头*/select::-ms-expand { display: none; }select {/*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/border: solid 1px #333;/*将默认的select选择框样式清除*/appearance:none;-moz-appearance:none;-webkit-appearance:none;/*在选择框的最右侧中间显示小箭头图片*/background: url(&quot;小箭头图片路径&quot;) no-repeat right center transparent;/*为下拉小箭头留出一点位置，避免被文字覆盖*/padding-right: 14px;/*去除点击出现轮廓颜色*/outline: none;}</code></pre><h3 id="美化button按钮"><a href="#美化button按钮" class="headerlink" title="美化button按钮"></a>美化button按钮</h3><pre><code>button{    /*本身有2px的边框，一般的button都不需要边框*/    border: none;    /*本身有的背景色，可以用其他颜色取代*/    background: #333;    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/}</code></pre><h3 id="css中设置table中的td内容自动换行，边框线合并为一条"><a href="#css中设置table中的td内容自动换行，边框线合并为一条" class="headerlink" title="css中设置table中的td内容自动换行，边框线合并为一条"></a>css中设置table中的td内容自动换行，边框线合并为一条</h3><pre><code>1. 把表格的sytle的table-layout: fixed;(就是表格固定宽度，就是表格既要自适应他外面的容器，也不要撑出去)2. 然后设置td的word-wrap: break-word;3. table边框线合并为一条：border-collapse: collapse;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;美化input框&quot;&gt;&lt;a href=&quot;#美化input框&quot; class=&quot;headerlink&quot; title=&quot;美化input框&quot;&gt;&lt;/a&gt;美化input框&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/*在IE10+浏览器中, 使用css即可隐藏input文本输入框右侧的叉号
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 基础命令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/06/20/12/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/06/20/12/</id>
    <published>2017-06-20T14:34:59.073Z</published>
    <updated>2018-03-21T13:59:47.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><pre><code>创建目录 mkdir &lt;目录名称&gt;删除目录 rm &lt;目录名称&gt;定位目录 cd &lt;目录名称&gt;查看目录文件 ls ll修改目录名 mv &lt;目录名称&gt; &lt;新目录名称&gt;拷贝目录 cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>创建文件 touch &lt;文件名称&gt; vi &lt;文件名称&gt;删除文件 rm &lt;文件名称&gt;修改文件名 mv &lt;文件名称&gt; &lt;新文件名称&gt;拷贝文件 cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></pre><p>文件内容操作</p><pre><code>查看文件 cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt;编辑文件内容 vi &lt;文件名称&gt;查找文件内容 grep &apos;关键字&apos; &lt;文件名称&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;创建目录 mkdir &amp;lt;目录名称&amp;gt;
删除目录 rm &amp;lt;目录名称&amp;gt;
定位目录 cd &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/05/13/11/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/05/13/11/</id>
    <published>2017-05-13T14:34:32.216Z</published>
    <updated>2018-03-21T13:54:55.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><pre><code>var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () {    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块    if (xhr.readyState == 4) {        if (xhr.status == 200) {            alert(xhr.responseText)        }    }}xhr.open(&quot;GET&quot;, &quot;/api&quot;, false)xhr.send(null)</code></pre><h2 id="状态码说明"><a href="#状态码说明" class="headerlink" title="状态码说明"></a>状态码说明</h2><p>上述代码中，有两处状态码需要说明。xhr.readyState是浏览器判断请求过程中各个阶段的，xhr.status是 HTTP 协议中规定的不同结果的返回状态说明。</p><p>xhr.readyState的状态码说明：</p><pre><code>0 - (未初始化）还没有调用send()方法1 -（载入）已调用send()方法，正在发送请求2 -（载入完成）send()方法执行完成，已经接收到全部响应内容3 -（交互）正在解析响应内容4 -（完成）响应内容解析完成，可以在客户端调用了</code></pre><p>xhr.response 的状态码说明：</p><p>xhr.status即 HTTP 状态码，有 2xx 3xx 4xx 5xx 这几种，比较常用的有以下几种：</p><pre><code>200 正常3xx    301 永久重定向。如http://xxx.com这个 GET 请求（最后没有/），就会被301到http://xxx.com/（最后是/）    302 临时重定向。临时的，不是永久的    304 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有If-Modified-Since: xxx（要求返回更新时间是xxx时间之后的资源），如果此时服务器 端资源未更新，则会返回304，即不符合要求404 找不到资源5xx 服务器端出错了</code></pre><h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>目前已经有一个获取 HTTP 请求更加方便的 API：Fetch，通过Fetch提供的fetch()这个全局函数方法可以很简单地发起异步请求，并且支持Promise的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a>，看下其浏览器兼容情况。</p><pre><code>fetch(&apos;some/api/data.json&apos;, {    method:&apos;POST&apos;, //请求类型 GET、POST    headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString    body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）    mode:&apos;&apos;, //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin    credentials:&apos;&apos;, //cookie 的跨域策略，如 omit、same-origin 或 include    cache:&apos;&apos;, //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached}).then(function(response) { ... });</code></pre><p>Fetch 支持headers定义，通过headers自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和cache策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和formData等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XMLHttpRequest&quot;&gt;&lt;a href=&quot;#XMLHttpRequest&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest&quot;&gt;&lt;/a&gt;XMLHttpRequest&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;var xhr = new 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端自动化构建环境的搭建</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/04/05/10/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/04/05/10/</id>
    <published>2017-04-05T09:54:34.940Z</published>
    <updated>2018-03-13T06:30:16.222Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端使用工程化方式构建；</p><p>   目前需要一些简单的功能：</p><pre><code>1. 版本控制6. 编译SASS2. 检查JS3. 图片合并4. 压缩CSS5. 压缩JS</code></pre><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>目前最知名的构建工具： Gulp、Grunt、NPM + Webpack；</p><pre><code>grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件</code></pre><h3 id="Use-Gulp-to-automate-front-end-build-tasks"><a href="#Use-Gulp-to-automate-front-end-build-tasks" class="headerlink" title="Use Gulp to automate front-end build tasks"></a>Use Gulp to automate front-end build tasks</h3><p>Gulp是基于 Node.js的，需要要安装 Node.js</p><p>1、为了确保依赖环境正确，我们先执行几个简单的命令检查。</p><pre><code>node -vNode是一个基于Chrome JavaScript V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号</code></pre><p>2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包</p><pre><code>npm -v这同样能得到npm的版本号，装 Node 时已经自动安装了npm</code></pre><p>3、开始安装Gulp</p><pre><code>npm install -g gulp全局安装 gulpgulp -v得到gulp的版本号，确认安装成功</code></pre><p>基础安装结束<br>-</p><p>4、切换到你的在项目根文件夹下，运行</p><pre><code>npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下</code></pre><p>5、安装gulp功能插件依赖包</p><pre><code>npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev</code></pre><blockquote><p>gulp功能模块的文件会放在项目所在的目录的./node_modules 下</p></blockquote><p>6、我们目前先使用一些简单的功能：</p><pre><code>- 检查Javascript- 编译Sass文件- 合并Javascript- 压缩合并并重命名Javascript</code></pre><blockquote><p>新建gulpfile.js 配置文件放在项目根目录下</p></blockquote><pre><code>演示项目目录结构   testProject        (项目名称)   |–.git             通过git进行版本控制,项目自动生成这个文件   |–node_modules     组件包目录   |–dist             **发布环境**（编译自动生成的）       |–css         样式文件(style.css style.min.css)       |–images     图片文件(压缩图片\合并后的图片)       |–js         js文件(main.js main.min.js)       |–index.html  静态页面文件(压缩html)   |–src             **开发环境**       |–sass                sass文件       |–images               图片文件       |–js                  js文件       |–index.html         静态文件   |–gulpfile.js              gulp配置文件   |–package.json             依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序</code></pre><blockquote><p>现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。</p></blockquote><pre><code>gulpfile.js内容如下：// 引入gulpvar gulp = require(&apos;gulp&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);//检查jsvar sass   = require(&apos;gulp-sass&apos;);    //编译Sassvar concat = require(&apos;gulp-concat&apos;);//合并var uglify = require(&apos;gulp-uglify&apos;);//uglify 组件（用于压缩 JS）var rename = require(&apos;gulp-rename&apos;);//重命名// 检查js脚本的任务gulp.task(&apos;lint&apos;, function() {    gulp.src(&apos;./js/*.js&apos;) //可配置你需要检查脚本的具体名字。        .pipe(jshint())        .pipe(jshint.reporter(&apos;default&apos;));});// 编译Sassgulp.task(&apos;sass&apos;, function() {    gulp.src(&apos;./scss/*.scss&apos;)        .pipe(sass())        .pipe(gulp.dest(&apos;./css&apos;));//dest()写入文件});// 合并，压缩js文件// 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下gulp.task(&apos;scripts&apos;, function() {    gulp.src(&apos;./js/*.js&apos;)        .pipe(concat(&apos;all.js&apos;))        .pipe(gulp.dest(&apos;./dist&apos;))        .pipe(rename(&apos;all.min.js&apos;))        .pipe(uglify())        .pipe(gulp.dest(&apos;./dist&apos;));        console.log(&apos;gulp task is done&apos;);//自定义提醒信息});.... // 其他任务类似// 定义默认任务,执行gulp会自动执行的任务gulp.task(&apos;default&apos;, function(){    gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;);    // 监听js文件变化，当文件发生变化后会自动执行任务    gulp.watch(&apos;./js/*.js&apos;, function(){        gulp.run(&apos;lint&apos;,&apos;scripts&apos;);    });});</code></pre><p>7、现在，回到命令行窗口，可以直接运行gulp任务了。</p><pre><code>gulp这将执行定义的default任务，就和以下的命令式同一个意思gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：gulp sass</code></pre><p>8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心</p><pre><code>常见提醒：1.禁止在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre><p>9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务</p><pre><code>常用的gulp插件参考gulp-imagemin:         压缩图片gulp-ruby-sass:     支持sass，安装此版本需要安装rubygulp-minify-css:     压缩cssgulp-jshint:          检查jsgulp-uglify:          压缩jsgulp-concat:        合并文件gulp-rename:          重命名文件gulp-htmlmin:         压缩htmlgulp-clean:          清空文件夹gulp-livereload:     服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）</code></pre><p>补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X)</p><pre><code>安装Node.Js、NPM、Ruby、Java 基础环境Sublime Text3 + 插件           用于编写前端代码Google chrome 、Mozilla Firefox + FirebugInternet Explorer             进行兼容测试和预览页面UI、动画效果和交互功能Node.js+Gulp                 进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等；Koala                         实时编译Less、Sass、Compass、CoffeeScript;Github                         存储自己的代码库 、git或SVN用于版本控制和团队Code ReviewTomcat、DedeAMPZ、MAMP      进行简单运行环境演示Photoshop CC 切图 + Sprites 合并小图标XMind                         画出清晰的工作或业务逻辑思维图</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web前端使用工程化方式构建；&lt;/p&gt;
&lt;p&gt;   目前需要一些简单的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 版本控制
6. 编译SASS
2. 检查JS
3. 图片合并
4. 压缩CSS
5. 压缩JS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些都是每个Web项目在构建、开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3 动画</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/03/23/09/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/03/23/09/</id>
    <published>2017-03-23T09:51:26.030Z</published>
    <updated>2018-03-21T13:34:39.487Z</updated>
    
    <content type="html"><![CDATA[<p> CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p><p>首先，使用@keyframes定义一个动画，名称为testAnimation，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。</p><pre><code>@keyframes testAnimation{0%   {background: red; left:0; top:0;}25%  {background: yellow; left:200px; top:0;}50%  {background: blue; left:200px; top:200px;}75%  {background: green; left:0; top:200px;}100% {background: red; left:0; top:0;}}</code></pre><p>然后，针对一个 CSS 选择器来设置动画，例如针对div元素设置动画，如下：</p><pre><code>div {    width: 100px;    height: 50px;    position: absolute;    animation-name: myfirst;    animation-duration: 5s;}</code></pre><p><strong>animation-name</strong>对应到动画名称，<strong>animation-duration</strong>是动画时长，还有其他属性：</p><pre><code>1. animation-timing-function：规定动画的速度曲线。默认是ease。2. animation-delay：规定动画何时开始。默认是 0。3. animation-iteration-count：规定动画被播放的次数。默认是 1。4. animation-direction：规定动画是否在下一周期逆向地播放。默认是normal。5. animation-play-state ：规定动画是否正在运行或暂停。默认是running。6. animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards。</code></pre><h2 id="CSS-的transition和animation有何区别？"><a href="#CSS-的transition和animation有何区别？" class="headerlink" title="CSS 的transition和animation有何区别？"></a>CSS 的transition和animation有何区别？</h2><p>首先transition和animation都可以做动效，从语义上来理解，transition是过渡，由一个状态过渡到另一个状态，比如高度100px过渡到200px；而animation是动画，即更专业做动效的，animation有帧的概念，可以设置关键帧keyframe，一个动画可以由多个关键帧多个状态过渡组成，另外animation也包含上面提到的多个属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。&lt;/p&gt;
&lt;p&gt;首先，使用@keyframes定义一个动画，名称为testAnimation，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/02/01/08/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/02/01/08/</id>
    <published>2017-02-01T04:59:59.580Z</published>
    <updated>2018-03-14T14:46:09.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul><li>BOM的核心是window，它表示浏览器的一个实例。window 对象既是通过 js 访问浏览器窗口的一个接口，又是 es 规定的Global 对象。</li><li>全局变量不能通过 delete 操作符删除，但是 window 对象上的属性是可以的。</li><li>直接访问为未声明的变量会报错，但是可以通过 window对象上的属性来查询某个未声明的变量是否存在。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue  <span class="comment">//会抛出错误，因为后者未声明</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h2><ul><li>JS 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，后者则是每隔指定的时间就执行一次。</li><li><code>setTimeout()</code>方法可以接受两个参数，第一个是要执行的代码，也可以是字符串，但是推荐用<code>function(){}</code>。后一个参数是执行前需要等待的毫秒数。传递字符串可能导致性能损失，因此不建议。</li><li>值得注意的是，经过了指定的毫秒，代码也不一定会执行。js 是一个单线程序的解释器，有一个任务队列。如果队列是空的，那么代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完毕以后再执行。</li><li>取消的时候可以用<code>clearTime()</code>方法.把相应的数字 id 传递进去。</li><li>注意在以上方法中this 指向全局，window 对象。严格模式下是 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeoutId 是一个数字 ID</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'heiheihei'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">clearTimeout(timeoutId) <span class="comment">//即立即取消这个超时调用</span></span><br></pre></td></tr></table></figure><ul><li>取消间隔调用<code>setInterval()</code>远比取消<code>setTimeout()</code>重要的多，因为间隔调用如果不干涉会一直执行。</li><li>一般认为，使用setTimeout 模拟 setInterval 是最佳实践。因为后一个间歇调用可能会在前一个间歇调用结束前启动。使用模拟方式则可以避免这一情况。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inc</span>(<span class="params"></span>) </span>&#123; <span class="comment">//模拟setInterval 方法，间隔增加直至最大值</span></span><br><span class="line">num++</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">setTimeout(inc, <span class="number">500</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(inc, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ul><li>location 是最有用的 BOM 对象之一，而且它既是 window 对象的属性，也是 document 对象的属性。 <code>window.location</code>和<code>document.location</code>引用的是同一个对象。</li><li><p>location 对象的用处不止表现在它保存着当前文档的信息，而且还可以通过不同属性访问 URL 的解析片段。</p><p>  属性名 | 例子 | 说明<br>  —-|:——:|—-<br>  hash | ‘#contents’  | URL 中的 hash，#后面的字符，没有则为空<br>  host | ‘<a href="http://www.baidu.com:80&#39;" target="_blank" rel="noopener">www.baidu.com:80&#39;</a>  | 服务器名称和端口号(如果有)<br>  hostname | ‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>  | 服务器名称<br>  href | ‘<a href="http://www.baidu.com:80/dd.html#hash1?q=name&#39;" target="_blank" rel="noopener">www.baidu.com:80/dd.html#hash1?q=name&#39;</a>  | 完整URL<br>  pathname | ‘/dd.html’  | URL 中的目录和文件名<br>  port|’80’|端口<br>  protocol| ‘http:’|协议名和冒号<br>  search|’?q=name’|查询字符串，别忘了有问号开头</p></li></ul><ul><li>尽管 <code>location.search</code> 可以查询到查询的字符串，但是没法逐个访问，并不方便。创建一个函数返回对象，得到对应的 key 和 value。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//字符串是否为空</span></span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">var</span> args = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">'&amp;'</span>) : []</span><br><span class="line">  <span class="keyword">var</span> item = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    item = items[i].split(<span class="string">'='</span>)</span><br><span class="line">    <span class="comment">//进行解码</span></span><br><span class="line">    name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">    value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">      args[name] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位置操作location"><a href="#位置操作location" class="headerlink" title="位置操作location"></a>位置操作location</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改 URL</span></span><br><span class="line">location.assign(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">'xxx'</span></span><br><span class="line">location.href = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><ul><li>上述的三种方式得到的效果完全一样，因为后面的两个也会调用assign()方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 URL 修改成'http://www.baidu.com#section1' 页面不跳转</span></span><br><span class="line">location.hash = <span class="string">'#section1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 url 修改成'http://www.baidu.com:80' 页面跳转</span></span><br><span class="line">location.port = <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>每次修改 location 的属性(hash 除外)，页面都会以新 URL 重新加载。</li><li>当通过上述任何一种方式修改 URL 后，浏览器的历史记录就会生成一条新纪录。通过后退按钮都会回到前一个页面。</li><li>使用 replace()方法可以禁用后退按钮。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浏览器跳转到百度，但不会在历史纪录中生成新纪录，而且不能回到之前的页面</span></span><br><span class="line">location.replace(<span class="string">'http://www.baidu.com'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>location.reload()</code>方法会让浏览器以最有效的方式重新加载，可能使用缓存。</li><li><code>location.reload(true)</code>方法会让浏览器强制完全重载。</li><li>reload()方法之后的代码<strong>可能，也可能不会执行</strong>，所以放在最后一行吧。</li></ul><p>##history 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>)<span class="comment">//后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>)<span class="comment">//前进一页</span></span><br><span class="line">history.go(<span class="number">2</span>)<span class="comment">//前进2页</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="string">'www.baidu.com'</span>) <span class="comment">//跳转到最近的百度页面，如果没有这条字符串，那么什么也不做</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">history.forwward()<span class="comment">//前进后退的简写方法</span></span><br><span class="line"></span><br><span class="line">history.length  <span class="comment">//数量，新加载的页面是0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BOM对象&quot;&gt;&lt;a href=&quot;#BOM对象&quot; class=&quot;headerlink&quot; title=&quot;BOM对象&quot;&gt;&lt;/a&gt;BOM对象&lt;/h1&gt;&lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/01/20/07/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/01/20/07/</id>
    <published>2017-01-20T00:57:13.545Z</published>
    <updated>2018-03-14T09:38:00.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><ul><li>文档节点 document 是每个文档的根节点。文档节点只有一个子节点，即 <code>&lt;html&gt;</code> 元素,称之为文档元素。在 HTML 中，文档元素始终是<code>&lt;html&gt;</code>元素。</li><li>HTML 元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，注释则通过注释节点表示。总共有12种节点类型，这些类型都继承于一个基类型。</li></ul><h2 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h2><ul><li>每个节点都有一个 nodeType 属性，用于表明节点类型。12个数值常量表示，任何节点类型必居其一。例如：</li></ul><ol><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li></ol><ul><li>为了确保浏览器兼容，最好还是将 nodeType 属性与数字进行比较，因为 IE 没有公开 Node 类型的构造函数。</li><li>并不是所有节点类型都收到浏览器支持，最常用的还是元素和文本节点。</li><li>对于元素节点，nodeName 中保存的始终是元素的标签名，nodeValue 的值始终是 null。</li></ul><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><ul><li>每个节点都有一个 childNodes 属性，保存着一个 NodeList 对象。这是一个类数组对象，就和 arguments 差不多。</li><li>它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映到 NodeList 对象中，可以当做是<strong>双向绑定</strong>的对象。</li><li>和 arguments 对象一样，可以使用<code>Array.prototype.slice.call(someNode.childNodes)</code>将 childNodes 转换成数组进行操作，方括号访问和 item()都是可以的，前者更常见些。</li><li>IE8及以前需要手动枚举，所以上述代码会失效。</li><li>每个节点有一个 parentNode 属性，指向文档树中的父节点。通过previousSibling和 nextSibling 属性，可以访问其他节点。如果没有前一个或后一个，值为 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nextSibling === <span class="literal">null</span>) &#123;  <span class="comment">//最后一个节点</span></span><br><span class="line">alert(<span class="string">'Last node'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.previousSibling === <span class="literal">null</span>) &#123; <span class="comment">//第一个节点</span></span><br><span class="line">alert(<span class="string">'First node!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有一个节点，那么这两个属性都会为 null。</li><li>父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点。<code>someNode.firstChild</code>始终等于<code>someNode.childNodes[0]</code>,<code>someNode.lastChild</code>始终等于<code>someNode.childNodes[someNode.childNodes.length-1]</code>。如果没有子节点，那么 firstChild 和 lastChild 始终为 null。</li><li>所有节点都有一个 ownerDocument 属性，指向整个文档的文档节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nod.ownerDocument  <span class="comment">//指向 document 节点</span></span><br></pre></td></tr></table></figure><h3 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h3><ul><li>appendChild()向 childNodes 列表末尾插入一个节点，默认返回新增节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(someNode)</span><br><span class="line"><span class="built_in">console</span>.log(returnNode === someNode) <span class="comment">//true  返回值即为插入的节点</span></span><br><span class="line"><span class="built_in">console</span>.log(someNode.lastChild === someNode) <span class="comment">//TRUE 最后一个节点为新插入的节点</span></span><br></pre></td></tr></table></figure><ul><li><p>如果传入到 appendChild()中的节点已经是文档中第一部分了，原位置就没有了这个节点，插入到新位置，相当于做了一次移动。</p></li><li><p>insertBefore()方法可以插入到某个特定位置，接受两个参数，插入的节点和作为参照的节点。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">returnNode = someNode.insertBefore(newNode, <span class="literal">null</span>)</span><br><span class="line">alert (returnNode === someNode.lastChild) <span class="comment">//true  插入成为最后一个节点</span></span><br><span class="line"></span><br><span class="line">returnNode = someNode.insertBefore(newNode, someNode.firstChild)</span><br><span class="line">alert (returnNode === someNode.firstChild) <span class="comment">//true 插入成为第一个节点</span></span><br></pre></td></tr></table></figure><ul><li>replaceChild()方法接受两个参数，插入的节点和要替换的节点，替换。</li><li>removeChild()方法接受一个参数，移除节点。</li><li>cloneNode()方法克隆节点，接受一个布尔值，true 表示深复制，也就是节点和整个子节点树。false 表示只复制节点本身。<strong>需要注意的是，这个节点返回的是复制后的节点，还需要手动方法把它插入到文档树中去。</strong></li><li>normalize()方法处理文档树中的文本节点，如果找到空文本节点就删除它，如果找到相邻的文本节点就合并为一个文本节点。</li></ul><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><ul><li>nodeType的值为9，nodeValue 的值为’#document’</li><li>document.domain可以设置。当页面包含来自其他子域的框架和内嵌框架时，能够设置 document.domain 就非常方便。如果两个页面的 document.domain 的值设置为一样，他们就可以进行通信了。如果域名一开始是松散的，那么就不可以在设置成紧绷的了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设页面来自于p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span>  <span class="comment">//成功，因为设置成了更松散的</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'p2p.wrox.com'</span> <span class="comment">//失败！因为设置成了更紧绷的域名</span></span><br></pre></td></tr></table></figure><ul><li>查找元素的两个方法：document.getElementById()，document.getElementByTagName()</li><li>第一个只返回第一次出现的元素，第二个返回的类数组对象HTMLCollection，也就是所有标签名一致的元素节点组，注意大小写尽量严格匹配，如果没找到会返回 null。</li><li>document.getElementByTagName()方法返回的类数组对象可以用 nameItem()访问也可以用方括号访问，传入 name 值。星号’*’代表全部。</li></ul><h2 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h2><ul><li>nodeType 的值是1，nodeName 的值为元素标签名，nodeValue 值为 null。</li><li>HTML 中所有标签都为大写，如果不确定是否为 HTML 或者 xml 最好进行标签名转换，toLowerCase()方法。不会出错。推荐做法。</li><li>取得特性：getAttribute(),setAttribute(), removeAttribute()方法。</li><li>setAttribute() 方法接受两个参数，特性名和值。如果特性存在，就会替换掉，如果特性不存在，直接创建并设置。</li><li>使用 document.createElement() 方法可以创建新元素。传入元素的标签名。</li></ul><h2 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h2><ul><li>nodeType 的值为3，nodeName 值为’#text’，nodeValue 值为节点所包含的文本。没有子节点。</li><li>通过 nodeValue 属性或者 data 属性修改文本。</li><li>通过 document.createTextNode()创建文本节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'&lt;strong&gt;Hello&lt;/strong&gt; World!'</span>)</span><br></pre></td></tr></table></figure><ul><li>一般情况下每个元素只有一个文本子节点，但如果我们自行删除或增加文本节点，会出现不是一个文本节点的情况。使用 normalize()方法进行去除空文本或者合并节点的操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.normalize()  <span class="comment">//element 元素的文本节点就会被规范化</span></span><br></pre></td></tr></table></figure><ul><li>Text 类型提供了一个与 normalize()相反的方法：splitText(),会按传入的数字分割 nodeValue 值，变成两个文本节点。原来的文本节点将包含开始到指定位置之前的内容，新文本节点将包含剩下的文本。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">element.className = <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'Hello world!'</span>)</span><br><span class="line">element.appendChild(textNode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>) <span class="comment">//方法返回的是后面的文本</span></span><br><span class="line">alert(element.firstChild.nodeValue)  <span class="comment">//'Hello'</span></span><br><span class="line">alert(newNode.nodeValue)  <span class="comment">//'world!'</span></span><br></pre></td></tr></table></figure><h2 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h2><ul><li>nodeType 的值是8，nodeName 值为’#comment’，nodeValue 是注释的内容，没有子节点。</li><li>Comment 类型和 Text 继承自相同的基类，拥有除了splitText()之外的所有字符串操作方法。也可以通过 nodeValue 和 data 取得内容。注释节点可以通过父节点访问。</li><li>这个节点很少进行操作，因为对算法鲜有影响。</li></ul><h2 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h2><ul><li>DocumentFragment 在文档中没有对应的标记。nodeType 值为11，nodeName 值为’#document-fragment’,nodeValue为 null。</li><li>创建文档片段可以使用 document.createDocumentFragment()方法，通常认为一次性的插入文档片段比多次浏览器渲染性能要高得多，所以如果有多次插入文档流的操作可以使用这个方式。</li></ul><h2 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h2><ul><li>nodeType 的值为2，nodeName 值为特性的名称，nodeValue 值为特性的值。</li><li>实际上，使用 getAttrbute()，setAtrribute(),removeAttribute()方法比操作节点更为方便。</li></ul><h1 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h1><ul><li>对 DOM 的两个主要的扩展是 Selectors API 和 HTML5.</li></ul><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><ul><li>Selectors API Level 1的核心是两个方法: querySelector()和 querySelectorAll().兼容性 IE8+。</li></ul><h3 id="querySelector方法"><a href="#querySelector方法" class="headerlink" title="querySelector方法"></a>querySelector方法</h3><ul><li>querySelector()方法接受一个 CSS 选择符，返回与该模式匹配的第一个元素，没有匹配返回 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>) <span class="comment">//获取 body 元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>) <span class="comment">//获取 ID 为 myDiv 的 div 元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">'.selected'</span>) <span class="comment">//获取 class 为 selected 的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">'img.button'</span>) <span class="comment">//获取类为 button 的 第一个 img 元素</span></span><br></pre></td></tr></table></figure><ul><li>通过 Document 类型调用 querySelector()方法时，会在文档元素范围内查找，通过 Element 类型查找时，则在该元素的后代元素范围内查找。</li><li>如果传入了不被支持的选择符，会报错。</li></ul><h3 id="querySelectorAll方法"><a href="#querySelectorAll方法" class="headerlink" title="querySelectorAll方法"></a>querySelectorAll方法</h3><ul><li>同上，返回的是一个 NodeList 实例。</li><li>具体来说，返回值实际上是一个带有所有属性和方法的 nodeList，底层实现列斯雨一组元素的快照，并非对文档进行搜索的动态查询。这样实现可以避免使用 NodeList 对象引起的大多数性能问题。</li><li>传入的 CSS 选择符有效，则返回一个 NodeList 对象，可能为空，如果传入了错误的选择符则抛出错误。</li></ul><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul><li>对于元素间的空格，IE9以及之前的版本不会返回文本节点，其他浏览器会返回文本节点。导致了使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一不一致，保持 DOM 规范不变，Element Travelsal规范重新定义了一组属性。</li></ul><table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">childElementCount</td><td style="text-align:center">返回子元素的个数</td></tr><tr><td style="text-align:center">firstElementChild</td><td style="text-align:center">指向第一个子元素,firstChild 的元素版</td></tr><tr><td style="text-align:center">lastElementChild</td><td style="text-align:center">指向最后一个子元素，lastChild 的元素版</td></tr><tr><td style="text-align:center">previousElementSibling</td><td style="text-align:center">前一个同级元素，previousSibling 的元素版</td></tr><tr><td style="text-align:center">nextElementSibling</td><td style="text-align:center">后一个同级元素，nextSiblingde 的元素版</td></tr></tbody></table><ul><li>利用这些元素不必担心空白文本节点，从而方便的查找元素。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = element.firstElementChild   <span class="comment">//元素的第一个子元素</span></span><br><span class="line"><span class="keyword">while</span> (child != element.lastElementChild) &#123;  <span class="comment">//并非最后一个子元素时，处理后，child 指向下一个子元素直至成为最后一个</span></span><br><span class="line">processChild(child)</span><br><span class="line">child = child.nextElementSibling</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h2><h3 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h3><ul><li>可以通过 doucument对象和所有的 HTML 元素进行调用，原生的实现让他具有极大性能优势。</li><li>接受一个参数，一个包含一或多个类名的字符串,返回带有指定类的所有元素的 NodeList。传入类名时，顺序先后不重要。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得所有类名为 username current 的元素，类名顺序无所谓</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsername = <span class="built_in">document</span>.getElementSByClassName(<span class="string">'username current'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得 ID 为 myDiv 的元素中带有类名selected 的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).getElementsByClassName(<span class="string">'selected'</span>)</span><br></pre></td></tr></table></figure><ul><li>和其他的选择器方法一样，只有位于调用元素树中的元素才会返回。</li><li>因为返回的对象是 NodeLst，所以使用这个方法与使用getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都有相同的性能问题。</li><li><strong>这里要多说两句，因为在循环中经常使用 i &lt; selected.length 这样的语句，但每一次判断 i 是否小于类数组对象的长度时，都会对 NodeList 对象进行一次访问查询，导致性能下降。如果通过一个变量缓存这个 length，性能可以提升50%左右。所以尽量减少访问属性的次数。</strong></li></ul><h3 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h3><ul><li>所有元素都添加了了 classList 属性，是新集合类型 DOMTokenList 的实例。</li><li>classList 对象有一个表示自己长度的 length 属性，要去的每个元素可以使用 item()方法或者方括号语法。</li></ul><table><thead><tr><th>方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>add(value)</td><td style="text-align:center">将给定的字符串添加到列表中，如果已经存在，就不添加</td></tr><tr><td>contains(value)</td><td style="text-align:center">表示列表中是否存在给定的值，如果存在就不添加</td></tr><tr><td>remove(value)</td><td style="text-align:center">从列表中删除字符串</td></tr><tr><td>toggle(value)</td><td style="text-align:center">类似 jQuery 中的切换类名</td></tr></tbody></table><ul><li>有了 classList 属性，除非需要全部删除所有类名，或者完全重写元素属性，否则也用不到 className 属性了。</li></ul><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><ul><li>document.activeElement 属性,这个属性会引用 DOM 当前获得焦点的元素，获得焦点的方式有页面加载，用户输入，focus()方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，文档刚刚加载完成时，activeElement 属性保存的是 document.body 元素的引用。加载期间值为 null。</li><li>另外，document.hasFocus()方法确定文档是否获得了焦点。只要文档加载完成或者其他元素调用了 focus()方法，这个返回值为 true.</li></ul><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><ul><li>HTML5规定可以为元素加载非标准的属性，添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加，随便命名，只要以 data-开头即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'myDiv'</span> data-appId=<span class="string">'12345'</span> data-myname=<span class="string">'Nicholas'</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>自定义属性可以通过元素的 dataset 属性访问。</li><li>dataset 属性是 DOMStringMap 的一个实例，也就是一个键值对的映射。访问的属性名没有 data-前缀。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myname</span><br><span class="line"></span><br><span class="line">div.dataset.appId = <span class="number">23456</span></span><br><span class="line">div.dataset.myname = <span class="string">'Michael'</span></span><br></pre></td></tr></table></figure><ul><li>如果给元素添加一些不可见的数据一遍进行其他处理，在跟踪连接和混搭应用中，自定义属性能方便的知道点击来自哪里。</li></ul><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li>通过 DOM 操作节点相对麻烦，因为不仅要创建，还要按照正确的顺序连接。使用插入标记的技术，直接插入 HTML 字符串更简单，速度也更快。</li></ul><h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><ul><li>读模式下，innerHTML 属性返回与调用元素的所有子节点（元素，注释，文本节点）对应的 HTML 标记。</li><li>写模式下，innerHTML 会根据指定的值创建新的 DOM 树，新的 DOM 树会完全取代原来的 DOM 节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="keyword">this</span> is a &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt;with a list following it&lt;/</span>p&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/对于上面的div 元素来说，它的 innerHTML 会返回如下字符串</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/</span>strong&gt;<span class="keyword">with</span> a list following it&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item2&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item3&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><ul><li>尽量注意，在通过 innerHTML 插入代码时，尽量收工检查一下其中的文本内容。</li></ul><h4 id="outerHTML-属性"><a href="#outerHTML-属性" class="headerlink" title="outerHTML 属性"></a>outerHTML 属性</h4><ul><li>基本同上，需要注意的是返回也会包括自身，看下面的例子。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="keyword">this</span> is a &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt;with a list following it&lt;/</span>p&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/对于上面的div 元素来说，它的 outerHTML 会返回如下字符串</span></span><br><span class="line"><span class="regexp">&lt;div id='content'&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/</span>strong&gt;<span class="keyword">with</span> a list following it&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item2&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item3&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a>insertAdjacentHTML()方法</h4><ul><li>接受两个参数，插入位置和要插入的 HTML 文本。</li><li>太乱，不写了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforebegin'</span>, <span class="string">'&lt;p&gt;helloworld&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure><h4 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h4><ul><li>在使用 innerHTML、outerHTML、insertAdjacentHTML()方法最好收工删除要被替换的元素的所有事件处理程序和 Javascript 对象属性。因为在使用前述某个属性将该元素从文档树中删除后，元素与事件处理程序之间的绑定关系在内存中并没有一并删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加。</li><li>再插入大量新 HTML 标记时，使用 innerHTML 属性与通过多次 DOM 操作先创建节点在指定他们的关系相比，效率高得多。因为设置 innerHTML 时，会创建 HTML 解析器（通常是 C++编写），比执行 js 快得多。</li><li>创建和销毁 HTML 解析器也会带来性能损失，所以最好不要频繁设置 innerHTML 等属性。</li></ul><h4 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a>scrollIntoView()方法</h4><ul><li>scrollIntoView()可以在所有 HTML 元素上调用，给方法传入 true 或者不传参，调用元素的顶部会与视窗顶部尽量平齐，如果传入 false，调用元素会尽量全部出现在视窗中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#b_fav'</span>)</span><br><span class="line"></span><br><span class="line">div.scrollIntoView() <span class="comment">//滚动至div 出现在视窗页面顶部</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOM对象&quot;&gt;&lt;a href=&quot;#DOM对象&quot; class=&quot;headerlink&quot; title=&quot;DOM对象&quot;&gt;&lt;/a&gt;DOM对象&lt;/h1&gt;&lt;h2 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS事件</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/12/12/06/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/12/12/06/</id>
    <published>2016-12-12T00:56:18.079Z</published>
    <updated>2018-03-13T07:29:13.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡和捕获阶段"><a href="#冒泡和捕获阶段" class="headerlink" title="冒泡和捕获阶段"></a>冒泡和捕获阶段</h2><p><img src="http://www.admin10000.com/UploadFiles/Document/201503/21/20150321132128500929.JPG" alt=""></p><ul><li>一图流解释：IE 事件流叫做事件冒泡，从元素逐级向上传递，所有现代浏览器支持事件冒泡。</li><li>事件捕获是网景团队提出，虽然规范要求应该从 document 对象开始，但浏览器基本都从 window 对象开始。特殊需求才会使用。</li></ul><h2 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h2><ul><li>需要注意的是，你以为点击蚊子，事件目标节点在div上，其实实际触发会在最深的节点，比如 p 或者 span 等子节点上。</li></ul><h2 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h2><ul><li><em>DOM2级事件</em>规定的事件流包括三个阶段：事件捕获，目标事件阶段和事件冒泡阶段。</li><li>规范要求：捕获阶段不触发目标元素事件，然后目标事件处理，再进行冒泡阶段。</li><li>然而多数浏览器在捕获阶段也实现了目标元素事件，导致有两次机会可以实现目标元素事件。IE9+。</li></ul><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><h3 id="HTML-内联属性（避免使用）"><a href="#HTML-内联属性（避免使用）" class="headerlink" title="HTML 内联属性（避免使用）"></a>HTML 内联属性（避免使用）</h3><ul><li>HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。</li><li>onclick 属性表示触发 click，属性值的内容（JavaScript 代码）会在单击该 HTML 节点时执行。</li><li>显而易见，使用这种方法，JavaScript 代码与 HTML 代码耦合在了一起，不便于维护和开发。所以除非在必须使用的情况（例如统计链接点击数据）下，尽量避免使用这种方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">'alert('</span>hhh<span class="string">')'</span>&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOM-属性绑定"><a href="#DOM-属性绑定" class="headerlink" title="DOM 属性绑定"></a>DOM 属性绑定</h3><ul><li>也可以直接设置 DOM 属性来指定某个事件处理的函数。</li><li>上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。</li><li>虽然也可以用一些方法实现多个绑定，但还是推荐标准事件监听函数。</li><li>这种方式添加的事件处理程序会在事件的冒泡阶段处理，同时 this 引用当前元素。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'ddd'</span>)</span><br><span class="line">&#125;<span class="comment">//属性绑定事件</span></span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="literal">null</span>   <span class="comment">//删除事件处理程序  HTML 绑定事件也可以这样解除</span></span><br></pre></td></tr></table></figure><h3 id="事件监听函数"><a href="#事件监听函数" class="headerlink" title="事件监听函数"></a>事件监听函数</h3><ul><li>addEventListener()和 removeEventListener()两个方法，所有 DOM 节点都包括这两个方法。</li><li>接受三个参数，事件名，处理函数，一个布尔值。</li></ul><table><thead><tr><th>布尔值</th><th>说明</th></tr></thead><tbody><tr><td>true</td><td>捕获阶段</td></tr><tr><td>false</td><td>冒泡阶段  常用</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListerner(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'ddd'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">btn.addEventListerner(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>) <span class="comment">//移除监听事件，注意必须是同一引用 handler</span></span><br></pre></td></tr></table></figure><ul><li>和上面的属性绑定事件相同，this 指向绑定的元素，false 是冒泡阶段触发，这也是最常用的，因为要兼容 IE。</li><li>最后移除事件监听只可以用 removeEventListener()方法，同时<strong>必须是同一引用函数，使用匿名函数，即使完全相同也是不可以的，因为并非同一引用</strong>。</li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li>在触发 DOM 上的某个事件时，会产生一个事件对象 event, 对象中包含这所有与事件相关的信息。</li><li>在事件处理程序内部，this 始终等于 currentTarget 的值，而 target 的值则只包含实际目标。如果直接属性绑定，this、currentTarget 和 target 指向目标，三者值相同。</li><li>如果事件处理程序存在于按钮的父节点，target 指向目标，currentTarget 和 this 指向父节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">alert(e.currentTarget === e.target)  <span class="comment">//true</span></span><br><span class="line">alert(e.target === <span class="keyword">this</span>)<span class="comment">//true 属性绑定，三者相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(e.currentTarget === e.target) <span class="comment">//false</span></span><br><span class="line">alert(e.currentTarget === <span class="keyword">this</span>)  <span class="comment">//true this 指向 body</span></span><br><span class="line">alert(e.target === btn) <span class="comment">//true 点击 btn 按钮，target 属性指向 btn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在需要通过一个函数处理多个事件时，可以使用 e.type 属性，定义一个函数，处理多种事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'click'</span> :</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">e.target.style.color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">e.target.style.color = <span class="string">'black'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler</span><br><span class="line">btn.onmouseover = handler</span><br><span class="line">btn.onmouseout = handler</span><br></pre></td></tr></table></figure><ul><li>阻止默认行为可以用 e.preventDefault()方法；只有 cancelable 属性为 true 的事件，才可以用 preventDefault()阻止默认事件。</li><li>e.stopPropagation()方法用于取消进一步的事件捕获或冒泡。例如注册在 btn 上的事件处理程序立即调用 e.stopPropagation()方法，从而避免触发注册在 document.body 上的事件。防止出现两次或者重叠的情况。</li><li>事件对象的 e.eventPhase 属性，用于确定正位于事件流的那个阶段。</li></ul><table><thead><tr><th>e.evenetPhase属性值</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>捕获阶段</td></tr><tr><td>2</td><td>事件处理程序正处于目标对象上</td></tr><tr><td>3</td><td>冒泡阶段</td></tr><tr><td>0</td><td>none</td></tr></tbody></table><ul><li>只有事件处理程序执行期间，event 对象才会存在，一旦事件处理程序执行完成，event 对象就会销毁。</li></ul><p><strong>下面列出一些 event 对象的属性值。</strong></p><table><thead><tr><th>属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>e.type   <strong>string</strong></td><td style="text-align:center">事件的名称，比如’click’</td></tr><tr><td>e.target <strong>node</strong></td><td style="text-align:center">事件要触发的目标节点</td></tr><tr><td>e.bubbles <strong>boolean</strong></td><td style="text-align:center">表明该时间是否在冒泡阶段触发</td></tr><tr><td>e.preventDefault()</td><td style="text-align:center">禁止默认事件</td></tr><tr><td>e.stopPropagation()</td><td style="text-align:center">停止进一步冒泡或捕获阶段</td></tr><tr><td>e.eventPhase <strong>number</strong></td><td style="text-align:center">见上</td></tr><tr><td>e.pageX和 e.pageY <strong>number</strong></td><td style="text-align:center">表示触发事件时，鼠标相对于页面的坐标</td></tr><tr><td>e.isTrusted <strong>boolean</strong></td><td style="text-align:center">浏览器触发（用户真实操作触发），还是 js 代码触发。</td></tr></tbody></table><h2 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h2><p>在 js 中，添加到页面上的事件处理程序数量将直接关系到页面运行性能。</p><ul><li>每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</li><li>必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul><li>事件委托利用了事件冒泡的机制，例如 click 事件会一直冒泡到 document 层次，只要给整个页面设置一个监听，就不不必分开一一设置了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>)</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = e.target</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line"><span class="keyword">case</span> btn:</span><br><span class="line">alert(<span class="string">'btn is clicked!'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> li:</span><br><span class="line">alert(<span class="string">'li is clicked!'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把 div 中的 btn 和 li 元素没有分开监听，给父元素设置lisener 同时根据元素的 id 进行切换，这就是初步的事件代理。</p><ul><li>如果可行的话，给 document 对象设置一个事件处理程序，泳衣处理页面上的某种特定类型的事件。</li><li>优点是，document 对象很快就可以访问，无需等待 DOMContentLoaded 或者 load 事件，只要可单击的元素成现在页面上，立即就可以具备适当的功能。</li><li>在页面中设置事件处理程序所需的事件更少，只添加一个监听事件，DOM 引用更少，花的时间也少。</li><li>整个页面占用的内存少，能够提升整体性能。</li></ul><p>最合适采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup和 keypress。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理很不容易，需要经常计算元素的位置。</p><h3 id="移除监听事件"><a href="#移除监听事件" class="headerlink" title="移除监听事件"></a>移除监听事件</h3><ul><li>文档中移除带有事件监听的元素时，removeChild(), replaceChild()，innerHTML 这些方法，很可能监听事件无法被当做垃圾回收。</li><li>再有就是卸载页面的时候，如果没有清理干净监听事件，就可能会只留在内存中。最好的做法是在页面卸载前，通过 onunload 事件移除所有监听事件，事件代理在此极具优势，因为监听事件很少。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>  <span class="comment">//设置为 null  移除监听事件</span></span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul><li>自定义事件可以实现更灵活的开发，用好了有很多优势。与之相关的函数有 Event 构造函数，CustomEvent 和 dispatchEvent。</li><li>直接自定义事件，使用 Event 构造函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>) <span class="comment">//new 一个Event 事件</span></span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;, <span class="literal">false</span>) <span class="comment">//设置元素build监听事件</span></span><br><span class="line"></span><br><span class="line">div.dispatchEvent(<span class="string">'event'</span>) <span class="comment">//触发事件</span></span><br></pre></td></tr></table></figure><ul><li>CustomEvent 可以创建一个更高度自定义事件，还可以附带一些数据，具体用法如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(eventname, options)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    detail: &#123;<span class="comment">//detail 里存放一些初始化信息</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    bubbles: <span class="literal">true</span>,<span class="comment">//其他属性</span></span><br><span class="line">    cancelable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.dispatchEvent(myEvent) <span class="comment">//手动触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结合起来使用即为：</span></span><br><span class="line">obj.addEventListener(<span class="string">'cat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'cat'</span>, options) <span class="comment">//自定义事件，options 为上述的那个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 jQuery 磨平兼容性，调用方法如下</span></span><br><span class="line">$(<span class="string">'#div'</span>).on(<span class="string">'cat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//绑定事件</span></span><br><span class="line">$(<span class="string">'#div'</span>).trigger(<span class="string">'cat'</span>) <span class="comment">//触发事件</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.admin10000.com/document/6089.html" target="_blank" rel="noopener">最详细的 js 事件</a> </p><p>JS 高程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡和捕获阶段&quot;&gt;&lt;a href=&quot;#冒泡和捕获阶段&quot; class=&quot;headerlink&quot; title=&quot;冒泡和捕获阶段&quot;&gt;&lt;/a&gt;冒泡和捕获阶段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.admin10000.com/UploadFiles/Do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSON格式详解</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/11/20/05/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/11/20/05/</id>
    <published>2016-11-20T00:54:57.171Z</published>
    <updated>2018-03-13T07:09:55.122Z</updated>
    
    <content type="html"><![CDATA[<p>JSON是一种数据格式，又是 JS 的一个严格的子集，但并不从属于JavaScript.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>简单值：字符串、数值、布尔值、null.<strong>不支持 js 中的特殊值 undefined。</strong></li><li>对象：一种复杂数据类型，无序键值对儿。其中的值可以为简单值，也可以是复杂数据类型值。</li><li>数组，一种复杂数据类型，有序的值的列表，可以通过数值索引访问，数组的值也可以是任意类型。</li></ol><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><ul><li>js 字符串与 JSON 字符串最大的不同，在于 JSON 字符串必须为双引号，单引号可能导致语法错误。</li><li>布尔值和 null 也是有效的 JSON 格式，但通常是会用复杂的数据结构表示 JSON 对象。</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>js 对象字面量和 JSON 格式大体相同，但 JSON 对象有两点不同，首先没有变量声明，也没有末尾的分号，另外值得注意的是，<strong>属性必须加双引号</strong>！忘了给属性加双引号，或者写成单引号都是常见错误。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line"><span class="string">"school"</span>: &#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"BUPT"</span>,</span><br><span class="line"><span class="string">"location"</span>: <span class="string">"beijing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>JSON 数组也没有变量和分号，对象和数组通常是 JSON 数据结构的最外层形式。但并不强制。</li></ul><h2 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h2><p>JSON之所以流行，主要的是可以把 JSON 数据结构解析为有用的 js 对象。简单清晰明了。</p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><h4 id="JSON-stringify-方法序列化的内部顺序："><a href="#JSON-stringify-方法序列化的内部顺序：" class="headerlink" title="JSON.stringify()方法序列化的内部顺序："></a>JSON.stringify()方法序列化的内部顺序：</h4><ol><li>如果存在 toJSON()方法，首先调用该方法，否则返回对象本身。</li><li>如果提供第二个参数，应用这个函数过滤器，第一个参数值为第一步传入的值。</li><li>对第二步返回的每个值进行相应的序列化。</li><li>如果提供了第三个参数，执行相应的序列化。</li></ol><ul><li>JSON.stringify()用于把 js 对象序列化为 JSON 字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">title: <span class="string">'professional js'</span>,</span><br><span class="line">authors: [</span><br><span class="line"><span class="string">'Nicholas'</span></span><br><span class="line">],</span><br><span class="line">edition: <span class="number">3</span>,</span><br><span class="line">year: <span class="number">2001</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)  <span class="comment">//jsonText 即为转换好的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;"title":"professional js","authors":["Nicholas"],"edition":3,"year":2001&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonText)</span><br></pre></td></tr></table></figure><ul><li>JSON.stringify()其实还可以接受另外两个参数，用于以不同的方式进行序列化。</li><li>第一个参数是个过滤器，可以是数组也可以是函数，第二个参数表示是否保留缩进。这两个参数可以单独或配合使用。</li><li>如果第一个传入的参数是数组，那么返回的结果只会包含数组列出的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到的JSON 字符串只有 title 和 edition 两个属性</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>])</span><br></pre></td></tr></table></figure><ul><li>如果第一个传入参数是函数，函数接受(key, value)两个参数，根据属性名分别处理属性，属性名只能是字符串。如果返回值是 undefined，那么相应的属性就不会出现在返回的 JSON 字符串中了。相当于删除该属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;  <span class="comment">//传入一个函数处理 key value</span></span><br><span class="line"><span class="keyword">switch</span>(key)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line"><span class="keyword">return</span> value.join(<span class="string">','</span>)<span class="comment">//没有 break 注意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'year'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'edition'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span>  <span class="comment">//相当于删掉这个属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>第三个参数用于处理缩进和空白符。如果是数值，那么代表缩进的空格数。如果是字符串，代表空白符。</li><li>无论是数值还是字符串，都只会保留10位，超出的会被忽略，结果中只会出现10个空格或前十个字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>) <span class="comment">//缩进4个字符</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="string">'----'</span>) <span class="comment">//缩进4个制表符</span></span><br></pre></td></tr></table></figure><ul><li>toJSON()方法。任何对象都可以添加 toJSON 方法，通过设置返回值使 JSON.stringify()生效。如果返回值为 undefined，如果是顶级对象，结果是 undefined，如果是包含在其他对象中，它的值为 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   title: <span class="string">'professional js'</span>,</span><br><span class="line">   authors: [</span><br><span class="line">     <span class="string">'Nicholas'</span></span><br><span class="line">   ],</span><br><span class="line">   edition: <span class="number">3</span>,</span><br><span class="line">   year: <span class="number">2001</span>,</span><br><span class="line">   toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//自定义 toJSON()方法</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.title</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)</span><br><span class="line"> <span class="built_in">console</span>.log(jsonText)  <span class="comment">// 返回的JSON 对象为"professional js"</span></span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><ul><li>JSON.parse()用于把 JSON 字符串解析为原生 js 值。</li><li>和 JSON.stringify()方法类似，parse()也可以接受第二个参数，是一个函数，将在每一个键值对上调用。参数也是 key、value 的形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">"releaseDate"</span>) &#123;<span class="comment">//通过判断 key，来进行相应 value 的操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSON是一种数据格式，又是 JS 的一个严格的子集，但并不从属于JavaScript.&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简单值：字符串、数值、布
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript创建对象和实现继承</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/10/02/04/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/10/02/04/</id>
    <published>2016-10-02T00:51:55.302Z</published>
    <updated>2018-03-22T02:41:43.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript创建对象"><a href="#JavaScript创建对象" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h2><h3 id="构造函数模式创建对象"><a href="#构造函数模式创建对象" class="headerlink" title="构造函数模式创建对象"></a>构造函数模式创建对象</h3><pre><code>function Person(name, job) {    this.name = name    this.job = job    this.sayName = function() {        console.log(this.name)    }}var person1 = new Person(‘Jiang’, ‘student’)var person2 = new Person(‘X’, ‘Doctor’)</code></pre><p>没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作</p><pre><code>创建一个新对象这个新对象会被执行[[prototype]]链接这个新对象会绑定到函数调用的this返回这个对象</code></pre><p>使用这个方式创建对象可以检测对象类型</p><pre><code>person1 instanceof Object // trueperson1 instanceof Person //true</code></pre><p>但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次</p><h3 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h3><pre><code>function Person() {}Person.prototype.name = ‘Jiang’Person.prototype.job = ‘student’Person.prototype.sayName = function() {console.log(this.name)}var person1 = new Person()</code></pre><p>将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。</p><p>原型是一个非常重要的概念，在一篇文章看懂proto和prototype的关系及区别中讲的非常详细</p><p>更简单的写法</p><pre><code>function Person() {}Person.prototype = {name: ‘jiang’,job: ‘student’,sayName: function() {    console.log(this.name)}}var person1 = new Person()</code></pre><p>将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。</p><p>使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里</p><p>Person.prototype.constructor === Person  // false<br>如果需要这个属性的话，可以手动添加</p><pre><code>function Person() {}Person.prototype = {    constructor：Person    name: ‘jiang’,    job: ‘student’,    sayName: function() {        console.log(this.name)    }}</code></pre><p>不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法</p><pre><code>Object.defineProperty(Person.prototype, ‘constructor’, {enumerable: false,value: Person})</code></pre><p>缺点使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点</p><p>原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了</p><pre><code>function Person() {}Person.prototype = {    name: ‘jiang’,    friends: [‘Shelby’, ‘Court’]}var person1 = new Person()var person2 = new Person()person1.friends.push(‘Van’)console.log(person1.friends) //[“Shelby”, “Court”, “Van”]console.log(person2.friends) //[“Shelby”, “Court”, “Van”]console.log(person1.friends === person2.friends) // true</code></pre><p>friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript创建对象&quot;&gt;&lt;a href=&quot;#JavaScript创建对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript创建对象&quot;&gt;&lt;/a&gt;JavaScript创建对象&lt;/h2&gt;&lt;h3 id=&quot;构造函数模式创建对象&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>引用类型</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/09/15/03/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/09/15/03/</id>
    <published>2016-09-15T00:51:16.563Z</published>
    <updated>2018-03-13T07:06:36.477Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ECMAScript</code> 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类。有时候也被成为<strong>对象定义</strong>，因为他们描述的是一类对象所具有的属性和方法。<br>如前所述，对象是某个特定引用类型的实例。</p><h2 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h2><ul><li>一般来说，访问对象属性有点表示法和方括号两种方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">'name'</span>]) <span class="comment">//'James'</span></span><br><span class="line">alert(person.name)    <span class="comment">//'James'</span></span><br></pre></td></tr></table></figure><p>这两种方式访问对象属性没有任何区别，但方括号可以通过<strong>变量</strong>访问属性；如果属性明中国年包含空格等可能导致语法错误的字符，或者属性名使用的是<strong>关键字或保留字</strong>，也可以使用方括号正确表达。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><ul><li>数组的 length 属性并不是只读的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]</span><br><span class="line">color.length = <span class="number">4</span></span><br><span class="line">alert(color[<span class="number">3</span>]) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><ul><li>利用 length 属性可以方便的添加末尾项。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color[color.length] = <span class="string">'black'</span></span><br></pre></td></tr></table></figure><ul><li>当设置超过数组长度的数组项时候，数组长度会被重新计算，空的数组项变成了<code>undefined</code>.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color[<span class="number">99</span>] = <span class="string">'brown'</span></span><br><span class="line">alert(color.length)  <span class="comment">//100</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray()</span><br></pre></td></tr></table></figure><ul><li><code>instanceof</code> 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，实际就存在两个以上不同的全局执行环境，从而存在两个以上的不同版本的 <code>Array</code> 构造函数。</li></ul><h3 id="栈方法和队列方法"><a href="#栈方法和队列方法" class="headerlink" title="栈方法和队列方法"></a>栈方法和队列方法</h3><ul><li><code>push()</code>方法可以接受<strong>任意数量</strong>的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。</li><li><code>pop()</code>方法则从数组末尾移走最后一项，减少数组 length，同时返回移除的项。</li><li><code>shift()</code>方法移除数组中的第一项并返回移除的数组项。</li><li><code>unshift()</code>方法则从数组的前端添加<strong>任意多项</strong>，返回数组长度。</li><li>由此可见：<code>push() unshift()</code>可以接受多项参数，<strong>返回的是数组长度 length</strong>；<code>pop() shift()</code>不接受参数，但是<strong>返回了一个添加项或者返回项</strong>。</li><li><code>shift() push()</code>方法可以模拟队列的方式使用数组，后进前出。</li><li><code>unshift() pop()</code>可以从相反方向模拟队列方法，前进后出。</li></ul><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul><li><code>reverse()</code>反转数组。</li><li><code>sort()</code>默认情况下按升序排列，同时会调用数组项的<code>toString()</code>方法，即使数组中都是数字，<strong>比较的也是字符串</strong>，所以常常出现10在5前这种情况。因此默认方法通常不用。</li></ul><p>以上两种返回的都是排序后的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v2-v1</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>].sort(compare)  <span class="comment">//返回的数组即可按升序排列</span></span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li><code>concat()</code>方法没有参数时只会返回复制的数组，有了参数后会返回添加参数后的数组。</li><li><code>slice()</code> 方法接受两个参数，起始位置和结束位置。第二个参数可不传。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>,<span class="string">'black'</span>,<span class="string">'brown'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = color.slice(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">alert(color2)   <span class="comment">//['blue','green','black']注意这个地方切到了4前</span></span><br></pre></td></tr></table></figure><ul><li><code>splice()</code>方法主要用来向数组中部插入项，一般是三种方式:</li><li>删除 : <code>splice(0，2)</code>要删除的位置和项数。</li><li>插入 :<code>splice(2,0,&#39;red&#39;,&#39;brown&#39;)</code>在位置2，插入两项。</li><li>替换 : <code>splice(2,1,&#39;red&#39;,&#39;brown&#39;)</code>在位置2删除一项，并插入两项。</li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul><li><code>indexOf()和 lastIndexOf()</code> 接受两个参数：要查找的项和起始位置(可选)。</li><li>只不过一个是从正向开始查找，另一个是从数组末尾开始，但是他们返回的<strong>都是找到的项的位置</strong>。</li></ul><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li><code>every()和 some()</code>返回的是布尔值，表示是否满足某个条件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> everyResult = color.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(everyResult) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><code>filter()</code>返回的是符合条件判断的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterResult = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(filterResult) <span class="comment">//[3,5,4,6]</span></span><br></pre></td></tr></table></figure><ul><li><code>map()</code>方法返回一个对数组的对应项进行操作后的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapResult = color.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item * <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(mapResult) <span class="comment">//[2,4,6,8,10]</span></span><br></pre></td></tr></table></figure><ul><li><code>forEach()</code>直接对数组进行操作，类似 for 循环。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//进行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><code>reduce() 和reduceRight()</code> 迭代所有项，返回一个最终值。一个正向迭代，一个从数组末尾向前开始。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceResult = color.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,next,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + next</span><br><span class="line">&#125; </span><br><span class="line">alert(reduceResult) <span class="comment">// 所有项想加的结果：15</span></span><br></pre></td></tr></table></figure><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li>函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。</li><li>函数声明和函数表达式是有区别的，解析器在代码执行之前，函数声明已经提升，而<strong>函数表达式只有执行到它所在的代码行，才会真正解释执行</strong>。</li></ul><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><ul><li>函数内部有两个特殊的对象<code>arguments 和 this</code>。</li><li><code>arguments</code>主要用来保存函数参数，还有一个<code>callee</code>属性，是一个指针，只想拥有这个 <code>arguments</code> 对象的函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * factorial(num <span class="number">-1</span>)</span><br><span class="line">&#125;    <span class="comment">//阶乘函数经典形式   问题在于过度紧密耦合了 factorial 函数名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num <span class="number">-1</span>)</span><br><span class="line">&#125; <span class="comment">//使用自身函数指针  arguments.callee 替代了函数名，解耦</span></span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><ul><li>每个函数都有两个属性：<code>length 和 prototype</code>。其中 length 表示函数接受的参数个数，就引用类型而言，<strong>prototype 是保存他们所有实例方法的真正所在</strong>。例如<code>toString()和 valueOf()</code>等方法实际都保存在 prototype 中，只不过是通过各自对象的实例访问罢了。</li><li>每个实例都包含两个非继承的方法<code>apply()和 call()</code>，实际上等于设置函数体内 this对象的值，真正强大的地方是能够扩充函数赖以运行的作用域。<code>call()</code>是分开接受参数，<code>apply()</code>是接受数组形式的参数。</li><li>使用 <code>apply()和 call()</code>来扩充作用域的最大好处就是，对象不需要与方法有任何耦合关系。此外<code>bind()</code>也是如此。</li></ul><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><h3 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h3><ul><li><code>encodeURI()</code>方法不会对本身属于 URI 的特殊字符进行编码，<code>：/ ? #</code>不会转义，会对空格转义。</li><li><code>encodeURIComponent()</code>会对所有非标字符转义。</li><li><strong>一般来说，<code>encodeURIComponent()</code>方法更常用，因为常见的是对查询字符串参数而不是对基础 URI 进行编码</strong>。</li><li><code>decodeURIComponent()和decodeURI()</code> 是对应的对上述两种方法解码的方法，<strong>注意是分别对应，不可交换。</strong></li><li><code>escape()</code>方法已废弃，实践中使用上述方法即可。</li></ul><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">16</span>)   <span class="comment">//只能对分别的数字参数使用</span></span><br><span class="line">alert(Max)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)</span><br><span class="line"><span class="comment">//这种方式即可对数组进行求最大值的正确姿势</span></span><br></pre></td></tr></table></figure><ul><li><code>random()</code>方法</li></ul><p>套用下面公式，即可从某个整数范围内随机选择一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">值 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * 可能值的总数 + 第一个可能的值)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从2到10之间选一个整数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectNum</span>(<span class="params">lowerVal, upperVal</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> choiceVal = upperVal - lowerVal + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choiceVal + lowerVal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = selectNum(<span class="number">2</span>, <span class="number">10</span>)    <span class="comment">// 2到10之间选择一个整数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;ECMAScript&lt;/code&gt; 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类。有时候也被成为&lt;strong&gt;对象定义&lt;/strong&gt;，因为他们描述的是一类对象所具有的属性和方法。&lt;br&gt;如前所述，对象是某个特定引用类型的实例。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>伪类、伪元素使用说明</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/08/05/02/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/08/05/02/</id>
    <published>2016-08-05T00:50:29.116Z</published>
    <updated>2018-03-13T06:07:04.021Z</updated>
    
    <content type="html"><![CDATA[<p>伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明；</p><p>简单区分：</p><pre><code>:Pseudo-classes        伪类:DOM在不同状态、不同位置下的特殊效果；::Pseudo-elements    伪元素：DOM按匹配规则伪造出的元素；</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul><li>伪类添加的内容元素或伪类效果通在DOM的源代码中是看不见的，需要借助开发者工具才能看见;</li><li>使用屏幕阅读器等设备无法访问和读取伪元素生成的内容。因此不应该使用伪元素来添加正文内容等重要信息到页面上展示，应确保主体内容的完整性。</li><li>伪类添加的元素也可以使用CSS样式进行控制,具体查看下面浏览器的兼容性；</li><li>content方式可以添加的图片、unicode、字符串；其中图片不能调整大小，要选择合适的图片;</li><li>伪元素是在DOM内容生成之后添加的，它将被堆积在DOM的父元素的顶上；</li><li>伪元素由双冒号和伪元素名称组成，为了兼容使用单冒号的伪类也有效；</li><li>伪类添加的内容和元素不能使用任何Javascript的事件处理程序；</li><li>js获取伪类的值：win.getComputedStyle(doc.querySelector(‘.element’), ‘:before’).getPropertyValue(‘color’)</li></ul><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><ul><li>具体浏览器兼容性可以使用 <a href="http://caniuse.com/#search=CSS3" target="_blank" rel="noopener">Can I Use</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN CSS Browser Support</a></li></ul><h4 id="常用伪元素、伪类列表"><a href="#常用伪元素、伪类列表" class="headerlink" title="常用伪元素、伪类列表"></a>常用伪元素、伪类列表</h4><pre><code>::after         在元素的内容之后::before          在元素的内容之前::first-line     元素的第一行::first-letter     元素的第一个字母::placeholder    占位符，用于input输入框之类的提醒::selection     被选取的元素，用于改变网页被选中部分的效果:active         当元素被点击的时:blank          空白的元素:checked          被选中的元素:default         默认被选中或默认会被提交的元素:dir()             匹配特定文字书写方向的元素:disabled        处于被禁止操作状态的元素:empty             没有任何内容的元素:enabled         处于可操作状态的元素:first             用于打印文档的第一页:first-child     父级元素下的第一个子元素:first-of-type     父级元素下的第一个同类子元素:focus             当元素成为焦点:fullscreen        当元素被HTML5 API调用RequestFullscreen方式全屏时:hover             当鼠标移动到链接元素上面时:in-range        当元素属性值处于其指定的范围内时    :indeterminate    当元素属性值处于不确定状态的:invalid        当元素属性值不是指定的type属性时:lang()          匹配有正确lang 属性值的元素，如 lang(zh-Hans):last-child        元素的最后一个子元素:last-of-type     元素的最后一个同类子元素:left            选择打印文档的左侧页:link             未被访问的链接元素:not()             否定选择器（不匹配条件则生效）:nth-child()     元素的一个或多个特定的子元素:nth-last-child() 元素的一个或多个特定的子元素，从该元素的最后一个子元素开始算；:nth-of-type()     选择指定的元素:nth-last-of-type()    选择指定的元素，从元素的最后一个开始计算:only-child        元素是它的父元素的唯一子元素:only-of-type     元素是它的父级元素的唯一一个相同类型的子元素:optional        未指定required属性的表单元素:out-of-range    超出规定值范围的元素:read-only        元素设置了 &apos;readonly&apos; 属性生效:read-write        元素没有 &quot;readonly&quot; 属性生效:required        设置了 &quot;required&quot; 属性的元素    :right            选择打印文档的左侧页:root             文档的根元素:scope            作用域的伪类，默认为HTML（案例 :scope #mammma {...}）:target         当前活动的元素（匹配页面URI中对应的目标元素）:valid             表示有效的元素:visited         已被访问过的元素 content        在元素之前或之后添加的内容。</code></pre><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/DOM/Using_fullscreen_mode" target="_blank" rel="noopener">Fullscreen API </a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:scope" target="_blank" rel="noopener">:scope</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明；&lt;/p&gt;
&lt;p&gt;简单区分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:Pseudo-classes        伪类:DOM在不同状态、不同位置下的特殊
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 简单使用说明</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2016/06/30/01/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2016/06/30/01/</id>
    <published>2016-06-30T00:49:44.968Z</published>
    <updated>2018-03-26T05:44:18.406Z</updated>
    
    <content type="html"><![CDATA[<p>1、安装git：</p><p>git是Windows版的Git，从git<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载</a>,然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>2、配置用户名：</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;</code></pre><p>3、创建仓库（或者 克隆一个远程仓库 ）：</p><pre><code>git initInitialized empty Git repository in /Users/michael/learngit/.git/ （告诉你是一个空的仓库）</code></pre><p>请确保目录名（包括父目录）不包含中文</p><p>4、添加文件到仓库：</p><p>把文件（readme.txt）放在创建的仓库内</p><pre><code>git add readme.txt  //可反复多次使用，</code></pre><p>添加多个文件；</p><pre><code>git add .</code></pre><p>（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。<br>用命令git commit告诉Git，把文件提交到仓库：</p><pre><code>git commit -m &quot;Update README.md, add the front-end interview questions &quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt</code></pre><p>5、修改文件后，更新仓库</p><pre><code>git status   查看仓库当前的状态， 告诉我们，什么文件被修改过了，但还没有准备提交的修改。git diff  文件名，  查看具体修改了什么内容git add 文件名    更新和添加一样git commit</code></pre><p>6、版本回退：</p><p>先 git log 添加的注释</p><p>也可以：git reflog 记录你的每一次添加命令和注释 和commit_id：</p><p>只回到上一个版本就是HEAD^，</p><pre><code>git reset --hard HEAD^</code></pre><p>上上一个版本就是HEAD^^ git reset –hard HEAD^^</p><pre><code>git reset --hard commit_id。</code></pre><p>7、暂存区</p><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>第一次修改 -&gt; add -&gt; 第二次修改 -&gt; add -&gt; commit</p><p>只会提交第一次的修改内容到主分支</p><p>8、撤销提交操作（add）</p><pre><code>git checkout -- readme.txt   //（--很重要，没有--，就变成了“创建一个新分支”的命令）</code></pre><p>把readme.txt文件在工作区的修改全部撤销，这里有两种情况：<br>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令</p><pre><code>git checkout -- file</code></pre><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，</p><p>第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作</p><p>二是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到【最近一次git commit后】 或【git add之前】的状态；</p><p>假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？ 可以回退到上一个版本。<br>不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p><p>9、删除文件</p><pre><code>1、预览将要删除的文件    git rm -r -n --cached 文件/文件夹名称     加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。2、确定无误后删除文件    git rm -r --cached 文件/文件夹名称3、提交到本地并推送到远程服务器    git commit -m &quot;提交说明&quot;    git push origin master4、修改本地 .gitignore 文件 并提交     git commit -m &quot;提交说明&quot;     git push origin master    //如果删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：    git checkout -- test.txt</code></pre><p>10、设置SSH Key</p><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要SSH Key</p><p>默认存放在 C:\Users\Administrator.ssh   id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><pre><code>ssh-keygen -t rsa -C “mygood@126.com&quot;</code></pre><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，<br>而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>11、绑定到远程仓库  （注意格式的gitlab，不支持ssh，请使用http）</p><pre><code>关联一个远程库   git remote add origin git@github.com:markyun/beilibao.git远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</code></pre><p>12、推送到远程仓库</p><pre><code>git remote -v //查看你当前项目远程连接的是哪个仓库地址。git push -u origin master //将本地的项目提交到远程仓库中。</code></pre><p>正常情况下这样显示：</p><pre><code>git push -u origin masterCounting objects: 19, done.o 4 threads.Compressing objects: 100% (Delta compression using upt19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.lliao/learngit.git * [new branch]Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michae  master -&gt; master to track remote branch master from origin.Branch master set up</code></pre><p>如果提示：</p><pre><code>ssh:connect to host github.com port 22:bad file number could not read from remote repository</code></pre><p>（说不能读取远端库，请确保有正确的访问权限并且仓库存在。看看你本机22端口有没有打开）</p><pre><code>ssh github.com 测试是否能正常使用SSH</code></pre><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><pre><code>The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.cting (yes/no)?Are you sure you want to continue conne</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。<br>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre><code>Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>13、从服务器上把一个远程仓库中的工程完全的拷贝下来</p><pre><code>git clone git@github.com:china-UED/test.git假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？git fetch origin    //取得远程更新，这里可以看做是准备要取了git merge origin/master  //把更新的内容合并到本地分支/master</code></pre><p>—————-待补充————–</p><p>14、创建与合并分支</p><p>15、冲突的处理</p><p>16、多人协作</p><p>17、其他</p><pre><code>git config --list 查看配置git config --global core.autocrlf false  关闭 github的换行符自动转换”功能</code></pre><p>补充 Git 命令快速查询表</p><pre><code>命令        简要说明git add    添加至暂存区git add–interactive    交互式添加git apply    应用补丁git am    应用邮件格式补丁git annotate    同义词，等同于 git blamegit archive    文件归档打包git bisect    二分查找git blame    文件逐行追溯git branch    分支管理git cat-file    版本库对象研究工具git checkout    检出到工作区、切换或创建分支git cherry-pick    提交拣选git citool    图形化提交，相当于 git gui 命令git clean    清除工作区未跟踪文件git clone    克隆版本库git commit    提交git config    查询和修改配置git describe    通过里程碑直观地显示提交IDgit diff    差异比较git difftool    调用图形化差异比较工具git fetch    获取远程版本库的提交git format-patch    创建邮件格式的补丁文件。参见 git am 命令git grep    文件内容搜索定位工具git gui    基于Tcl/Tk的图形化工具，侧重提交等操作git help    帮助git init    版本库初始化git init-db*    同义词，等同于 git initgit log    显示提交日志git merge    分支合并git mergetool    图形化冲突解决git mv    重命名git pull    拉回远程版本库的提交git push    推送至远程版本库git reBase    分支变基git rebase–interactive    交互式分支变基git reflog    分支等引用变更记录管理git remote    远程版本库管理git repo-config*    同义词，等同于 git configgit reset    重置改变分支“游标”指向git rev-parse    将各种引用表示法转换为哈希值等git revert    反转提交git rm    删除文件git show    显示各种类型的对象git stage*    同义词，等同于 git addgit stash    保存和恢复进度git status    显示工作区文件状态git tag    里程碑管理</code></pre><p>2、对象库操作相关命令</p><pre><code>命令    简要说明git commit-tree    从树对象创建提交git hash-object    从标准输入或文件计算哈希值或创建对象git ls-files    显示工作区和暂存区文件git ls-tree    显示树对象包含的文件git mktag    读取标准输入创建一个里程碑对象git mktree    读取标准输入创建一个树对象git read-tree    读取树对象到暂存区git update-index    工作区内容注册到暂存区及暂存区管理git unpack-file    创建临时文件包含指定 blob 的内容git write-tree    从暂存区创建一个树对象</code></pre><p>3、引用操作相关命令</p><pre><code>命令    简要说明git check-ref-format    检查引用名称是否符合规范git for-each-ref    引用迭代器，用于shell编程git ls-remote    显示远程版本库的引用git name-rev    将提交ID显示为友好名称git peek-remote*    过时命令，请使用 git ls-remotegit rev-list    显示版本范围git show-branch    显示分支列表及拓扑关系git show-ref    显示本地引用git symbolic-ref    显示或者设置符号引用git update-ref    更新引用的指向git verify-tag    校验 GPG 签名的Tag</code></pre><p>4、版本库管理相关命令</p><pre><code>命令    简要说明git count-objects    显示松散对象的数量和磁盘占用git filter-branch    版本库重构git fsck    对象库完整性检查git fsck-objects*    同义词，等同于 git fsckgit gc    版本库存储优化git index-pack    从打包文件创建对应的索引文件git lost-found*    过时，请使用 git fsck –lost-found 命令git pack-objects    从标准输入读入对象ID，打包到文件git pack-redundant    查找多余的 pack 文件git pack-refs    将引用打包到 .git/packed-refs 文件中git prune    从对象库删除过期对象git prune-packed    将已经打包的松散对象删除git relink    为本地版本库中相同的对象建立硬连接git repack    将版本库未打包的松散对象打包git show-index    读取包的索引文件，显示打包文件中的内容git unpack-objects    从打包文件释放文件git verify-pack    校验对象库打包文件</code></pre><p>5、数据传输相关命令</p><pre><code>命令    简要说明git fetch-pack    执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象git receive-pack    执行 git push 命令时在远程执行的命令，用于接受推送的数据git send-pack    执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据git upload-archive    执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档git upload-pack    执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</code></pre><p>6、邮件相关命令</p><pre><code>命令    简要说明git imap-send    将补丁通过 IMAP 发送git mailinfo    从邮件导出提交说明和补丁git mailsplit    将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件git request-pull    创建包含提交间差异和执行PULL操作地址的信息git send-email    发送邮件</code></pre><p>7、协议相关命令</p><pre><code>命令    简要说明git daemon    实现Git协议git http-backend    实现HTTP协议的CGI程序，支持智能HTTP协议git instaweb    即时启动浏览器通过 gitweb 浏览当前版本库git shell    受限制的shell，提供仅执行Git命令的SSH访问git update-server-info    更新哑协议需要的辅助文件git http-fetch    通过HTTP协议获取版本库git http-push    通过HTTP/DAV协议推送git remote-ext    由Git命令调用，通过外部命令提供扩展协议支持git remote-fd    由Git命令调用，使用文件描述符作为协议接口git remote-ftp    由Git命令调用，提供对FTP协议的支持git remote-ftps    由Git命令调用，提供对FTPS协议的支持git remote-http    由Git命令调用，提供对HTTP协议的支持git remote-https    由Git命令调用，提供对HTTPS协议的支持git remote-testgit    协议扩展示例脚本</code></pre><p>8、版本库转换和交互相关命令</p><pre><code>命令    简要说明git archimport    导入Arch版本库到Gitgit bundle    提交打包和解包，以便在不同版本库间传递git cvsexportcommit    将Git的一个提交作为一个CVS检出git cvsimport    导入CVS版本库到Git。或者使用 cvs2gitgit cvsserver    Git的CVS协议模拟器，可供CVS命令访问Git版本库git fast-export    将提交导出为 git-fast-import 格式git fast-import    其他版本库迁移至Git的通用工具git svn    Git 作为前端操作 Subversion</code></pre><p>9、合并相关的辅助命令</p><pre><code>命令    简要说明git merge-base    供其他脚本调用，找到两个或多个提交最近的共同祖先git merge-file    针对文件的两个不同版本执行三向文件合并git merge-index    对index中的冲突文件调用指定的冲突解决工具git merge-octopus    合并两个以上分支。参见 git merge 的octopus合并策略git merge-one-file    由 git merge-index 调用的标准辅助程序git merge-ours    合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略git merge-recursive    针对两个分支的三向合并。参见 git merge 的recursive合并策略git merge-resolve    针对两个分支的三向合并。参见 git merge 的resolve合并策略git merge-subtree    子树合并。参见 git merge 的 subtree 合并策略git merge-tree    显式三向合并结果，不改变暂存区git fmt-merge-msg    供执行合并操作的脚本调用，用于创建一个合并提交说明git rerere    重用所记录的冲突解决方案</code></pre><p>10、 杂项</p><pre><code>命令    简要说明git bisect–helper    由 git bisect 命令调用，确认二分查找进度git check-attr    显示某个文件是否设置了某个属性git checkout-index    从暂存区拷贝文件至工作区git cherry    查找没有合并到上游的提交git diff-files    比较暂存区和工作区，相当于 git diff –rawgit diff-index    比较暂存区和版本库，相当于 git diff –cached –rawgit diff-tree    比较两个树对象，相当于 git diff –raw A Bgit difftool–helper    由 git difftool 命令调用，默认要使用的差异比较工具git get-tar-commit-id    从 git archive 创建的 tar 包中提取提交IDgit gui–askpass    命令 git gui 的获取用户口令输入界面git notes    提交评论管理git patch-id    补丁过滤行号和空白字符后生成补丁唯一IDgit quiltimport    将Quilt补丁列表应用到当前分支git replace    提交替换git shortlog    对 git log 的汇总输出，适合于产品发布说明git stripspace    删除空行，供其他脚本调用git submodule    子模组管理git tar-tree    过时命令，请使用 git archivegit var    显示 Git 环境变量git web–browse    启动浏览器以查看目录或文件git whatchanged    显示提交历史及每次提交的改动git-mergetool–lib    包含于其他脚本中，提供合并/差异比较工具的选择和执行git-parse-remote    包含于其他脚本中，提供操作远程版本库的函数git-sh-setup    包含于其他脚本中，提供 shell 编程的函数库</code></pre><p><a href="http://www.bootcss.com/p/git-guide/" title="git-guide" target="_blank" rel="noopener">git-guide </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、安装git：&lt;/p&gt;
&lt;p&gt;git是Windows版的Git，从git&lt;a href=&quot;https://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载&lt;/a&gt;,然后按默认选项安装即可。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
</feed>
